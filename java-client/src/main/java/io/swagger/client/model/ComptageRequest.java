/**
 * API iSendPro
 * [1] Liste des fonctionnalités : - envoi de SMS à un ou plusieurs destinataires, - lookup HLR, - récupération des récapitulatifs de campagne, - gestion des répertoires, - ajout en liste noire. - comptage du nombre de caractères des SMS  [2] Pour utiliser cette API vous devez: - Créer un compte iSendPro sur https://isendpro.com/ - Créditer votre compte      - Remarque: obtention d'un crédit de test possible sous conditions - Noter votre clé de compte (keyid)   - Elle vous sera indispensable à l'utilisation de l'API   - Vous pouvez la trouver dans le rubrique mon \"compte\", sous-rubrique \"mon API\" - Configurer le contrôle IP   - Le contrôle IP est configurable dans le rubrique mon \"compte\", sous-rubrique \"mon API\"   - Il s'agit d'un système de liste blanche, vous devez entrer les IP utilisées pour appeler l'API   - Vous pouvez également désactiver totalement le contrôle IP 
 *
 * OpenAPI spec version: 1.0.0
 * Contact: support@isendpro.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package io.swagger.client.model;

import java.util.Objects;
import com.google.gson.annotations.SerializedName;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;


/**
 * ComptageRequest
 */
@javax.annotation.Generated(value = "class io.swagger.codegen.languages.JavaClientCodegen", date = "2016-08-08T09:49:05.172Z")
public class ComptageRequest   {
  @SerializedName("keyid")
  private String keyid = null;

  /**
   * Gets or Sets comptage
   */
  public enum ComptageEnum {
    @SerializedName("1")
    _1("1");

    private String value;

    ComptageEnum(String value) {
      this.value = value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
  }

  @SerializedName("comptage")
  private ComptageEnum comptage = ComptageEnum._1;

  @SerializedName("date_envoi")
  private String dateEnvoi = null;

  @SerializedName("sms")
  private String sms = null;

  @SerializedName("num")
  private String num = null;

  @SerializedName("emetteur")
  private String emetteur = null;

  @SerializedName("tracker")
  private String tracker = null;

  /**
   * Le SMS long permet de dépasser la limite de 160 caractères en envoyant un message constitué de plusieurs SMS. Il est possible d’envoyer jusqu’à 6 SMS concaténés pour une longueur totale maximale de 918 caractères par message. Pour des raisons technique, la limite par SMS concaténé étant de 153 caractères. En cas de modification de l’émetteur, il faut considérer l’ajout automatique de 12 caractères du « STOP SMS ». Pour envoyer un smslong, il faut ajouter le paramètre smslong aux appels. La valeur de SMS doit être le nombre maximum de sms concaténé autorisé.   Pour ne pas avoir ce message d’erreur et obtenir un calcul dynamique du nombre de SMS alors il faut renseigner smslong = \"999\" 
   */
  public enum SmslongEnum {
    @SerializedName("999")
    _999("999");

    private String value;

    SmslongEnum(String value) {
      this.value = value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
  }

  @SerializedName("smslong")
  private SmslongEnum smslong = SmslongEnum._999;

  @SerializedName("nostop")
  private String nostop = null;

  @SerializedName("ucs2")
  private String ucs2 = null;

  public ComptageRequest keyid(String keyid) {
    this.keyid = keyid;
    return this;
  }

   /**
   * Clé API
   * @return keyid
  **/
  @ApiModelProperty(example = "null", required = true, value = "Clé API")
  public String getKeyid() {
    return keyid;
  }

  public void setKeyid(String keyid) {
    this.keyid = keyid;
  }

  public ComptageRequest comptage(ComptageEnum comptage) {
    this.comptage = comptage;
    return this;
  }

   /**
   * Get comptage
   * @return comptage
  **/
  @ApiModelProperty(example = "null", required = true, value = "")
  public ComptageEnum getComptage() {
    return comptage;
  }

  public void setComptage(ComptageEnum comptage) {
    this.comptage = comptage;
  }

  public ComptageRequest dateEnvoi(String dateEnvoi) {
    this.dateEnvoi = dateEnvoi;
    return this;
  }

   /**
   * Date d'envoi au format YYYY-MM-DD hh:mm . Ce paramètre est optionnel, si il est omis l'envoi est réalisé immédiatement.
   * @return dateEnvoi
  **/
  @ApiModelProperty(example = "null", value = "Date d'envoi au format YYYY-MM-DD hh:mm . Ce paramètre est optionnel, si il est omis l'envoi est réalisé immédiatement.")
  public String getDateEnvoi() {
    return dateEnvoi;
  }

  public void setDateEnvoi(String dateEnvoi) {
    this.dateEnvoi = dateEnvoi;
  }

  public ComptageRequest sms(String sms) {
    this.sms = sms;
    return this;
  }

   /**
   * Message à envoyer aux destinataires. Le message doit être encodé au format utf-8 et ne contenir que des caractères existant dans l'alphabet GSM. Il est également possible d'envoyer (à l'étranger uniquement) des SMS en UCS-2, cf paramètre ucs2 pour plus de détails.
   * @return sms
  **/
  @ApiModelProperty(example = "null", required = true, value = "Message à envoyer aux destinataires. Le message doit être encodé au format utf-8 et ne contenir que des caractères existant dans l'alphabet GSM. Il est également possible d'envoyer (à l'étranger uniquement) des SMS en UCS-2, cf paramètre ucs2 pour plus de détails.")
  public String getSms() {
    return sms;
  }

  public void setSms(String sms) {
    this.sms = sms;
  }

  public ComptageRequest num(String num) {
    this.num = num;
    return this;
  }

   /**
   * Numero de téléphone au format national (exemple 0680010203) ou international (example 33680010203)
   * @return num
  **/
  @ApiModelProperty(example = "null", required = true, value = "Numero de téléphone au format national (exemple 0680010203) ou international (example 33680010203)")
  public String getNum() {
    return num;
  }

  public void setNum(String num) {
    this.num = num;
  }

  public ComptageRequest emetteur(String emetteur) {
    this.emetteur = emetteur;
    return this;
  }

   /**
   * - L'emetteur doit être une chaîne alphanumérique comprise entre 4 et 11 caractères.  - Les caractères acceptés sont les chiffres entre 0 et 9, les lettres entre A et Z et l’espace.  - Il ne peut pas comporter uniquement des chiffres.   - Pour la modification de l'émetteur et dans le cadre de campagnes commerciales, les opérateurs imposent contractuellement d'ajouter en fin de message le texte \"STOP XXXXX\". De ce fait, le message envoyé ne pourra excéder une longueur de 148 caractères au lieu des 160 caractères, le « STOP » étant rajouté automatiquement. 
   * @return emetteur
  **/
  @ApiModelProperty(example = "null", value = "- L'emetteur doit être une chaîne alphanumérique comprise entre 4 et 11 caractères.  - Les caractères acceptés sont les chiffres entre 0 et 9, les lettres entre A et Z et l’espace.  - Il ne peut pas comporter uniquement des chiffres.   - Pour la modification de l'émetteur et dans le cadre de campagnes commerciales, les opérateurs imposent contractuellement d'ajouter en fin de message le texte \"STOP XXXXX\". De ce fait, le message envoyé ne pourra excéder une longueur de 148 caractères au lieu des 160 caractères, le « STOP » étant rajouté automatiquement. ")
  public String getEmetteur() {
    return emetteur;
  }

  public void setEmetteur(String emetteur) {
    this.emetteur = emetteur;
  }

  public ComptageRequest tracker(String tracker) {
    this.tracker = tracker;
    return this;
  }

   /**
   * Le tracker doit être une chaine alphanumérique de moins de 50 caractères. Ce tracker sera ensuite renvoyé en paramètre des urls pour les retours des accusés de réception. 
   * @return tracker
  **/
  @ApiModelProperty(example = "null", value = "Le tracker doit être une chaine alphanumérique de moins de 50 caractères. Ce tracker sera ensuite renvoyé en paramètre des urls pour les retours des accusés de réception. ")
  public String getTracker() {
    return tracker;
  }

  public void setTracker(String tracker) {
    this.tracker = tracker;
  }

  public ComptageRequest smslong(SmslongEnum smslong) {
    this.smslong = smslong;
    return this;
  }

   /**
   * Le SMS long permet de dépasser la limite de 160 caractères en envoyant un message constitué de plusieurs SMS. Il est possible d’envoyer jusqu’à 6 SMS concaténés pour une longueur totale maximale de 918 caractères par message. Pour des raisons technique, la limite par SMS concaténé étant de 153 caractères. En cas de modification de l’émetteur, il faut considérer l’ajout automatique de 12 caractères du « STOP SMS ». Pour envoyer un smslong, il faut ajouter le paramètre smslong aux appels. La valeur de SMS doit être le nombre maximum de sms concaténé autorisé.   Pour ne pas avoir ce message d’erreur et obtenir un calcul dynamique du nombre de SMS alors il faut renseigner smslong = \"999\" 
   * @return smslong
  **/
  @ApiModelProperty(example = "null", value = "Le SMS long permet de dépasser la limite de 160 caractères en envoyant un message constitué de plusieurs SMS. Il est possible d’envoyer jusqu’à 6 SMS concaténés pour une longueur totale maximale de 918 caractères par message. Pour des raisons technique, la limite par SMS concaténé étant de 153 caractères. En cas de modification de l’émetteur, il faut considérer l’ajout automatique de 12 caractères du « STOP SMS ». Pour envoyer un smslong, il faut ajouter le paramètre smslong aux appels. La valeur de SMS doit être le nombre maximum de sms concaténé autorisé.   Pour ne pas avoir ce message d’erreur et obtenir un calcul dynamique du nombre de SMS alors il faut renseigner smslong = \"999\" ")
  public SmslongEnum getSmslong() {
    return smslong;
  }

  public void setSmslong(SmslongEnum smslong) {
    this.smslong = smslong;
  }

  public ComptageRequest nostop(String nostop) {
    this.nostop = nostop;
    return this;
  }

   /**
   * Si le message n’est pas à but commercial, vous pouvez faire une demande pour retirer l’obligation du STOP. Une fois votre demande validée par nos services, vous pourrez supprimer la mention STOP SMS en ajoutant nostop = \"1\"
   * @return nostop
  **/
  @ApiModelProperty(example = "null", value = "Si le message n’est pas à but commercial, vous pouvez faire une demande pour retirer l’obligation du STOP. Une fois votre demande validée par nos services, vous pourrez supprimer la mention STOP SMS en ajoutant nostop = \"1\"")
  public String getNostop() {
    return nostop;
  }

  public void setNostop(String nostop) {
    this.nostop = nostop;
  }

  public ComptageRequest ucs2(String ucs2) {
    this.ucs2 = ucs2;
    return this;
  }

   /**
   * Il est également possible d’envoyer des SMS en alphabet non latin (russe, chinois, arabe, etc) sur les numéros hors France métropolitaine. Pour ce faire, la requête devrait être encodée au format UTF-8 et contenir l’argument ucs2 = \"1\" Du fait de contraintes techniques, 1 SMS unique ne pourra pas dépasser 70 caractères (au lieu des 160 usuels) et dans le cas de SMS long, chaque sms ne pourra dépasser 67 caractères. 
   * @return ucs2
  **/
  @ApiModelProperty(example = "null", value = "Il est également possible d’envoyer des SMS en alphabet non latin (russe, chinois, arabe, etc) sur les numéros hors France métropolitaine. Pour ce faire, la requête devrait être encodée au format UTF-8 et contenir l’argument ucs2 = \"1\" Du fait de contraintes techniques, 1 SMS unique ne pourra pas dépasser 70 caractères (au lieu des 160 usuels) et dans le cas de SMS long, chaque sms ne pourra dépasser 67 caractères. ")
  public String getUcs2() {
    return ucs2;
  }

  public void setUcs2(String ucs2) {
    this.ucs2 = ucs2;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ComptageRequest comptageRequest = (ComptageRequest) o;
    return Objects.equals(this.keyid, comptageRequest.keyid) &&
        Objects.equals(this.comptage, comptageRequest.comptage) &&
        Objects.equals(this.dateEnvoi, comptageRequest.dateEnvoi) &&
        Objects.equals(this.sms, comptageRequest.sms) &&
        Objects.equals(this.num, comptageRequest.num) &&
        Objects.equals(this.emetteur, comptageRequest.emetteur) &&
        Objects.equals(this.tracker, comptageRequest.tracker) &&
        Objects.equals(this.smslong, comptageRequest.smslong) &&
        Objects.equals(this.nostop, comptageRequest.nostop) &&
        Objects.equals(this.ucs2, comptageRequest.ucs2);
  }

  @Override
  public int hashCode() {
    return Objects.hash(keyid, comptage, dateEnvoi, sms, num, emetteur, tracker, smslong, nostop, ucs2);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ComptageRequest {\n");
    
    sb.append("    keyid: ").append(toIndentedString(keyid)).append("\n");
    sb.append("    comptage: ").append(toIndentedString(comptage)).append("\n");
    sb.append("    dateEnvoi: ").append(toIndentedString(dateEnvoi)).append("\n");
    sb.append("    sms: ").append(toIndentedString(sms)).append("\n");
    sb.append("    num: ").append(toIndentedString(num)).append("\n");
    sb.append("    emetteur: ").append(toIndentedString(emetteur)).append("\n");
    sb.append("    tracker: ").append(toIndentedString(tracker)).append("\n");
    sb.append("    smslong: ").append(toIndentedString(smslong)).append("\n");
    sb.append("    nostop: ").append(toIndentedString(nostop)).append("\n");
    sb.append("    ucs2: ").append(toIndentedString(ucs2)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}

